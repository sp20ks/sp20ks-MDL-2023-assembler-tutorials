# Лабораторная работа №2 *"Программирование целочисленных выражений"*

## Теоретический материал
### 1. Что такое машинная команда? Какие форматы имеют машинные команды процессора IA32? Чем различаются эти форматы?
* **Машинная команда** - инструкция машине, выполняемая ею автоматически без каких-либо дополнительных указаний и пояснений.

* Размер машинной команды процессора IA-32 может меняться от 1 до 15 байт. Команда состоит из префикса (опционально), кода операции, байта mod, байта sib (опционально), смещения и непосредственно операнда.

   **Важно!** Различают два типа форматов: содержащие и не содержащие байта sib: если содержимое поля m (r/m) не равно 100, то байт sib в команде отсутствует.

### 2. Мнемоники основных команд целочисленной арифметики. Используемые форматы.

* **add** - сложение

        Допустимые форматы:
            add reg, reg
            add mem, reg
            add reg, mem
            add mem,imm
            add reg,imm
* **sub** - вычитание
            
        Допустимые форматы: идентичны add
* **mul** - умножение
            
        Допустимые форматы:
            mul r|m8  ; AX= AL*<Операнд2>
            mul r|m16 ; DX:AX= AX*<Операнд2>
            mul r|m32 ; EDX:EAX= EAX*<Операнд2>
* **imul** - умножение со знаком
            
        Допустимые форматы:
            imul r|m8  ; AX= AL*<Операнд2>
            imul r|m16 ; DX:AX= AX*<Операнд2>
            imul r|m32 ; EDX:EAX= EAX*<Операнд2>
* **div** - деление
            
        Допустимые форматы:
            div r|m8  ; AL= AX:<Операнд2>, AH – остаток
            div r|m16 ; AX= (DX:AX):<Операнд2>, DX – остаток
            div r|m32 ; EAX= (EDX:EAX):<Операнд2>, EDX – остаток
* **idiv** - деление со знаком
            
            Допустимые форматы:
            idiv r|m8  ; AL= AX:<Операнд2>, AH – остаток
            idiv r|m16 ; AX= (DX:AX):<Операнд2>, DX – остаток
            idiv r|m32 ; EAX= (EDX:EAX):<Операнд2>, EDX – остаток

### 3. Основные правила построения линейной программы вычисления заданного выражения.
* Заносим переменные выражения в секцию инициализированных данных .data
* Выделяем переменную для хранения результата выражения в секции неинициализированных данных .bss
* Код счета выражения в секцию кода .text
* При выделении памяти под переменные учитываем диапазон входных данных, чтобы не происходило ошибок переполнения.

  
### 4. Почему ввод-вывод на языке ассемблера не программируют с использованием соответствующих машинных команд? Какая библиотека используется для организации ввода вывода в данной лабораторной?
* Ввод-вывод пишется без использования машинных команд, чтобы не было зависимостей от особенностей языка. В данной лабораторной работе используется библиотека std.

### 5. Расскажите, какие операции используют при организации ввода-вывода.
* При организации ввода-вывод используют системные функции read/write, при этом необходимо указать дескриптор файла stdin(0)/stdout(1). Также используют syscall, который вызывает системную функцию.

## На что стоит обратить особое внимание при выполнении лабораторной работы
* Не у всех команд явно указываются два операнда. Например, команда умножения имеет только один операнд, на который умножается *содержимое регистра **EAX***. Нужно быть внимательным, чтоб не затереть нужные данные.
* Если операнд лежит в памяти, то в некоторых командах нужно оказывать явно его размер.
  
  
        idiv DWORD[A]

* При программировании вычислений стоит помнить, что есть команды, учитывающие и **не**учитывающие знак.
* Иногда при делении результат от деления не будет влазить в rax. Можно пользоваться командами расширения переменных.
* Используя либу ГС для преобразования строк в числа и наоборот, есть неочевидная вещь:
  
        ; преобразование int -> str
        mov rsi, Buffer
        mov rax, [Q]
        call IntToStr64
        
        ; вывод результата
        mov rdx, rax ; длина строки
        mov rax, 1; системная функция 1 (write)
        mov rdi, 1; дескриптор файла stdout=1
        mov rsi, Buffer ; адрес выводимой строки
        ; вызов системной функции
        syscall
    Здесь после вызова процедуры преобразования числа в строку длина результирущей строки будет лежать в **RAX**.